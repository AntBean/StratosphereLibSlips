/**
*
*    SLIPS - Stratosphere Linux IPS
*
*    Author: Sebastian Garcia.
*    Email : eldraco@gmail.com , sebastian.garcia@agents.fel.cvut.cz
*
*    Stratosphere IPS, a behavioral-based intrusion detection and prevention
*    system that uses machine learning algorithms to detect malicious behaviors
*    Website : https://stratosphereips.org/
*
*    libSlips - CPP Implementation of Stratosphere IPS
*    markov_models_1.cc is written by Sachin Vernekar (savernek@cisco.com)
*			and Urvesh Devani (udevani@cisco.com)
*
*    Copyright (C) 2016, Cisco Systems Inc.
*
*    This library is free software; you can redistribute it and/or
*    modify it under the terms of the GNU Lesser General Public
*    License as published by the Free Software Foundation; either
*    version 2.1 of the License, or (at your option) any later version.
*
*    This library is distributed in the hope that it will be useful,
*    but WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    Lesser General Public License for more details.
*
*    You should have received a copy of the GNU Lesser General Public
*    License along with this library; if not, write to the Free Software
*    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
*
**/
#include <iostream>
#include <sstream>
#include <fstream>
#include <cmath>
#include <stdlib.h>
#include <dirent.h>
#include <regex>
#include "markov_models_1.h"
#include "constants.h"

using std::cerr;
using std::cout;
using std::endl;

#define MAX_CHAR_PER_LINE 80000
std::string lower_case(std::string str);

//flags to keep parsing status in check for Model
typedef enum
{
    INIT =		0x0001,
    TRANS =		0x0010,
    STR_LITERAL = 	0x0100,
} flags;

Model::Model(int id)
{
    this->id = id;
    self_probability = -1;
    label = "";
    best_matching_len = -1;
    model_state = true;
    protocol = "";
}

Model::Model()
{
    self_probability = -1;
    label = "";
    best_matching_len = -1;
    model_state = true;
    protocol = "";
}

void Model::set_model_state(bool model_state)
{
    this->model_state = model_state;
}

void Model::clear()
{
    model_state = false;
    init_vector.clear();
    label = "";
    best_matching_len = -1;
    matrix.clear();
}

bool Model::get_model_state()
{
    return model_state;
}

void Model::set_best_model_matching_len(int statelen)
{
    best_matching_len = statelen;
}

int Model::get_best_model_matching_len()
{
    return best_matching_len;
}

bool Model::create(std::string state)
{
    // Create the Markov chain itself. We use the parameter instead of the attribute so we can compute the matrix for different states.
    // Separete the letters considering the letter and the symbol as a unique state:
    // So from "88,a,b," we get: '8' '8,' 'a,' 'b,'
    if (state.empty())
    {
        cerr << "WARNING: There is no state yet";
        return false;
    }

    // This is a first order markov model. Each individual object (letter, number, etc.) is a state
    // Generate the MC
    MarkovData md = maximum_likelihood_probabilities(state, 1);
    init_vector = md.init_vector;
    matrix = md.matrix;
    return true;
}

double Model::compute_probability(std::string state)
{
    // Given a chain of letters, return the probability that it was generated by this MC
    size_t i = 0;
    double probability = 0;
    double penalty = -4.6;  // Which is approx 0.01 probability
    double init_letter_prob;
    // Get the initial probability of this letter in the IV.
    // Need not use string::at here as if init_vector not empty, state isn't empty, but just to be safe.
    if (init_vector.empty() || init_vector.find(state.at(i)) == init_vector.end())
    {
        // We don't have an init_vector nor matrix, because we are still building them for each state. This is the first state
        // We assign it 0 so we don't influence the prob
        init_letter_prob = 0;
    }
    else if (init_vector[state.at(i)] <= 0)
    {
        // There is not enough data to even create a matrix
        init_letter_prob = 0;
    }
    else if (state.empty())
    {
        // The first letter is not in the matrix, so penalty...
        init_letter_prob = penalty;
    }
    else
    {
        init_letter_prob = log(init_vector[state[i]]);
    }
    // Assign the first letter prob
    probability = init_letter_prob;
    // We should have more than 2 states at least
    while (i < state.size() && state.size() > 1)
    {
        if (matrix.get_matrix_state())
        {
            std::string vector;
            if (state.size() > (i + 1))
            {
                vector.push_back(state[i]);
                vector.push_back(state[i + 1]);
            }
            else
            {
                break;
            }
            // The transitions that include the # char will be automatically excluded
            double temp_prob = matrix.walk_probability(vector);
            i += 1;
            if (temp_prob != -INFINITY)
            {
                probability = probability + temp_prob; // logs should be summed up
            }
            else
            {
                // Here is our trick. If two letters are not in the matrix... assign a penalty probability
                // The temp_prob is the penalty we assign if we can't find the transition
                probability = probability + penalty; // logs should be +
                continue;
            }
        }
        else
        {
            // We are out of letters
            break;
        }
    }
    return probability;
}

void Model::set_state(std::string state)
{
    this->state = state;
}

std::string
Model::get_state()
{
    return state;
}

int Model::get_id()
{
    return id;
}

void Model::set_init_vector(std::map<char, double> vector)
{
    init_vector = vector;
}

std::map<char, double>
Model::get_init_vector()
{
    return init_vector;
}

void Model::set_matrix(Matrix matrix)
{
    this->matrix = matrix;
}

Matrix Model::get_matrix()
{
    return matrix;
}

void Model::set_self_probability(double prob)
{
    self_probability = prob;
}

double Model::get_self_probability()
{
    return self_probability;
}

void Model::set_protocol(std::string protocol)
{
    this->protocol = protocol;
}

std::string Model::get_protocol()
{
    return protocol;
}

void Model::set_label(std::string label)
{
    this->label = label;
    std::vector<std::string> temp_vec;
    split(label, '-', temp_vec);
    if(temp_vec.size() > 2)
        set_protocol(temp_vec[2]);
    else
        cerr << "WARNING: Unknown protocol for model: " << label <<endl;
    // Set the responce that should be given if matched
    if(lower_case(this->label).find("normal") != std::string::npos)
        matched = false;
    else
        matched = true;
}

std::string Model::get_label()
{
    return label;
}

void Model::set_threshold(double threshold)
{
    this->threshold = threshold;
}

double Model::get_threshold()
{
    return threshold;
}

const std::string MarkovModelsDetection::basic_patterns[] = 
{
    "a,a,a,",
    "b,b,b,",
    "c,c,c,",
    "d,d,d,",
    "e,e,e,",
    "f,f,f,",
    "g,g,g,",
    "h,h,h,",
    "i,i,i,",
    "a+a+a+",
    "b+b+b+",
    "c+c+c+",
    "d+d+d+",
    "e+e+e+",
    "f+f+f+",
    "g+g+g+",
    "h+h+h+",
    "i+i+i+",
    "a*a*a*",
    "b*b*b*",
    "c*c*c*",
    "d*d*d*",
    "e*e*e*",
    "f*f*f*",
    "g*g*g*",
    "h*h*h*",
    "i*i*i*",
    "A,A,A,",
    "B,B,B,",
    "C,C,C,",
    "D,D,D,",
    "E,E,E,",
    "F,F,F,",
    "G,G,G,",
    "H,H,H,",
    "I,I,I,",
    "A+A+A+",
    "B+B+B+",
    "C+C+C+",
    "D+D+D+",
    "E+E+E+",
    "F+F+F+",
    "G+G+G+",
    "H+H+H+",
    "I+I+I+",
    "A*A*A*",
    "B*B*B*",
    "C*C*C*",
    "D*D*D*",
    "E*E*E*",
    "F*F*F*",
    "G*G*G*",
    "H*H*H*",
    "I*I*I*"
};

MarkovModelsDetection::MarkovModelsDetection()
{
    models.clear();
}

bool MarkovModelsDetection::is_periodic(std::string state)
{
    for (size_t i = 0; i < num_patterns; i++)
    {
        if (state.find(basic_patterns[i]) != std::string::npos)
            return true;
    }
    return false;
}

void MarkovModelsDetection::set_model_to_detect(const char* file)
{
    // Receives a file and extracts the model in it
    if(models.size() > 0)
    {
        id = models[models.size() - 1].get_id() + 1;
    }
    else
    {
        id = 1;
    }

    //printf("model_file:%s .......",file);
    Model botnet(id);
    char buf[MAX_CHAR_PER_LINE];
    char keyinit;
    char keytrans[2];
    int transOn = 0; // flag to check whether parsing of a transaction is already on
    int sprob = 0; // flag tocheck whether self probability is parsed
    std::regex letter("\'([^\"]*)\'");
    flags f1 = flags(0);

    std::ifstream fin;
    fin.open(file);
    while(!fin.eof())
    {
        memset(keytrans, 0, sizeof(keytrans));
        memset(buf, 0, sizeof(buf));
        fin.getline(buf, MAX_CHAR_PER_LINE);
        // Parsing init probabilities for each state
        if (!(f1 & INIT) && (strcmp(buf, "s.ccopy_reg") != 0))
        {
            std::string str(buf);
            if ((str.find("'") != std::string::npos))
            {
                std::regex_iterator<std::string::iterator> current(str.begin(), str.end(), letter);
                keyinit = char(current->str()[1]);
            }
            else if ((str.find("F") != std::string::npos))
            {
                botnet.init_vector[keyinit] = atof((str.substr(1)).c_str());
                //cout << "Init_vector botnet : " <<  keyinit << " , " << botnet.init_vector[keyinit] << endl;
            }
        }
        else if (!(f1 & INIT))
        {
            f1 = flags(f1 | INIT);
        }
        else if ((f1 & INIT) && !(f1 & TRANS) && strcmp(buf, "S'itemlist'") != 0)
        {
            // Parsing Transactional probabilities among states
            std::string str(buf);
            if ((str.find("'") != std::string::npos))
            {
                std::regex_iterator<std::string::iterator> current(str.begin(), str.end(), letter);
                if (!transOn)
                {
                    keytrans[0]= char(current->str()[1]);
                    transOn = 1;
                }
                else
                {
                    keytrans[1] = char(current->str()[1]);
                    transOn = 0;
                }
            }
            else if ((str.find("F") != std::string::npos))
            {
                std::string temp(keytrans);
                botnet.matrix.matrix[temp] = atof((str.substr(1)).c_str());
            }
        }
        else if ((f1 & INIT) && !(f1 & TRANS))
        {
            f1 = flags(f1 | TRANS);
        }
        else if ((f1 & INIT) && (f1 & TRANS) && !(f1 & STR_LITERAL) && strcmp(buf, "p1") != 0)
        {
            // Parsing behavioral model
            std::string str(buf);
            if ((str.find("ssb") != std::string::npos))
            {
                botnet.set_state(str.substr(6, str.size()-7));
            }
        }
        else if ( (f1 & INIT) && (f1 & TRANS) && !(f1 & STR_LITERAL))
        {
            f1 = flags(f1 | STR_LITERAL);
        }
        else if ( (f1 & INIT) && (f1 & TRANS) && (f1 & STR_LITERAL) && strcmp(buf, "p1") != 0)
        {
            std::string str(buf);
            if ((str.find(".F") != std::string::npos))
            {
                if(!sprob)
                {
                    botnet.set_self_probability(atof((str.substr(2)).c_str()));
                    sprob = 1;
                }
                else
                {
                    botnet.set_threshold(atof((str.substr(2)).c_str()));
                    sprob = 0;
                }
            }
            else if ((str.find(".S") != std::string::npos))
            {
                std::regex_iterator<std::string::iterator> current(str.begin(), str.end(), letter);
                botnet.set_label(current->str().substr(1, current->str().size()-2));
            }
        }
    }
    //cout << "\nAdding model to the list" << botnet.get_label() << endl;
    models.push_back(botnet);
    fin.close();
    //printf("Added\n");
}

DetectionInfo MarkovModelsDetection::detect(Tuple tuple, int verbose) throw(int)
{
    //Main detect function
    try
    {
        // Clear the temp best model
        Model best_model_so_far;
        best_model_so_far.set_model_state(false);
        double best_distance_so_far = INFINITY;
        // Set the verbose
        this->verbose = verbose;
        // Only detect states with more than 3 letters
        if (tuple.get_state().size() < 4)
        {
            if (this->verbose > 3)
                cout << "\t-> State too small" <<endl;

            DetectionInfo detection_info;
            return detection_info;
        }
        // Use the current models for detection
        for(size_t i = 0; i < models.size(); i++)
        {
            // Only detect if protocol matches
            if (lower_case(models[i].get_protocol()).compare(lower_case(tuple.get_protocol())) != 0)
            {
                // Go get the next
                continue;
            }
            // Letters of the trained model. Get from the last detected letter to the end. NO CUT HERE. We dont cut the training letters, because if we do, we have to cut ALL of them,
            // including the matching and the not matching ones.
            std::string train_sequence = models[i].get_state().substr(0, std::min(tuple.get_state().size(), models[i].get_state().size()));
            // Recreate the matrix so far
            models[i].create(train_sequence);
            // Get the new original prob so far...
            double training_original_prob = models[i].compute_probability(train_sequence);
            // Now obtain the probability for testing. The prob is computed by using the API on the train model, which knows its own matrix
            double test_prob = models[i].compute_probability(tuple.get_state());
            // Get the distance
            double prob_distance = -1;
            if (training_original_prob != -1 && test_prob != -1 && training_original_prob <= test_prob)
            {
                if (test_prob != 0)
                {
                    prob_distance = training_original_prob / test_prob;
                }
                else
                {
                    prob_distance = -1;
                }
            }
            else if (training_original_prob != -1 && test_prob != -1 && training_original_prob > test_prob)
            {
                if(training_original_prob != 0)
                {
                    prob_distance = test_prob / training_original_prob;
                }
                else
                {
                    prob_distance = -1;
                }
            }

            if (verbose > 2)
            {
                cout << "\t\t Trained Model : " << models[i].get_id() << ". Label: " << models[i].get_label() << ". Threshold: " << models[i].get_threshold() << ", State: " << train_sequence << endl;
                cout << "\t\t\t Test Model : " << tuple.get_id() << ". State : " << tuple.get_state() << endl;
                cout << "\t\t\t Train prob : " << training_original_prob << endl;
                cout << "\t\t\t Test prob : " << test_prob << endl;
                cout << "\t\t\t Distance : " << prob_distance << endl;
                if (verbose > 4)
                {
                    cout << "\t\t\tTrained Matrix"<<endl;
                    models[i].get_matrix().print_matrix();
                }
            }
            // If we matched and we are the best so far
            if (prob_distance >= 1 && prob_distance <= models[i].get_threshold() && prob_distance < best_distance_so_far)
            {
                // Store for this model, where it had its match. Len of the state. So later we can cut the state.
                models[i].set_best_model_matching_len(tuple.get_state().size());
                // Now store the best
                best_model_so_far = models[i];
                best_distance_so_far = prob_distance;
                if (verbose > 3)
                {
                    cout << "\t\t\t\tThis is the best model so far. State len: " << tuple.get_state().length() << endl;
                }
            }
        }
        // If we detected something
        if (best_model_so_far.get_model_state())
        {
            DetectionInfo detection_info(best_model_so_far.matched, best_model_so_far.get_label(), best_model_so_far.get_best_model_matching_len());
            return detection_info;
        }
        else
        {
            DetectionInfo detection_info;
            return detection_info;
        }
    }
    catch(std::exception &e)
    {
        cerr << "ERROR: Problem in detect() in markov_models_1\n" << e.what() <<endl;
        throw(ERROR_UNEXPECTED_ERROR);
    }
    catch(...)
    {
        cerr << "ERROR: Problem in detect() in markov_models_1" << endl;
        throw(ERROR_UNEXPECTED_ERROR);
    }
}


std::string lower_case(std::string str)
{
    std::string temp_str(str);
    std::transform(temp_str.begin(), temp_str.end(), temp_str.begin(), ::tolower);
    return temp_str;
}
